<!DOCTYPE html>
<html>

<body>

    <script src="http://kjur.github.io/jsrsasign/jsrsasign-latest-all-min.js"></script>
    <script src="catShipChain.js"></script>
    <script src="userWallet.js"></script>
    <script>
        /* 
                                        CatshipCoin is a very special coin that can only be generated by playing a video game 
                                        and getting a score high enough to mine a block. 
                                        The inherent randomness in the game prevents simple replay attacks from mining coins.

                                        Small coinbase rewards Score * 10^-6 * RandomNumber(1-10^4) are created with each game but in order to mine a block the almost impossible buggy first level needs to be passed at which point the block gets mined and the miner gets a 50 coin reward.
                                        The catship chain is a cryptic and powerful ancient technology that is mystical and mythical in all its facilities.
                                        
                                        a block is confirmed as soon as >50% of the netwrok starts mining on top of it and then they 
                                        periodically submit their best hash / score to the block to get stored in that block for when someone wins the game.

                                        Each persons score is carried over to the next block as a difficulty adjustment.
                                        */
        // inputs to the wallet / miner, if they don't exist they get created
        /*
        var userPrivateKey = '274387afe92a46c0fb1fe3271892c1d38955a783baf7fd7ffe89a25fff4e1e07'
        var userPublicKey = '04a0ca271b2e123e97001ccf99770d25e23f7b07f736d5f2399ad2ec446d10db1e766d61e3816d84994b99da593a0416c3555bf64a7b676d192b3e78106adfb20c';
        */
        var userMessage = 'Have a coffee on me scallywag';
        var userValue = '2.03';
        var receiverPublicKey = '04f9cc17bde90abb9a366b30a6357d428843790c7ab67987558e3912c6721cd4ad75ec8ae5eebff1c87dd4a56de7ce9b08bf0f3fb7e8d454bb2a0e5104b452e284';

        // global variables fed from the peers
        var currentCoinReward = '100.000000000';
        var currentDifficulty = '7';

        if (typeof catShipChain === 'undefined') {
            console.log('did not find a catship block chain, creating an empty one...');
            var catShipChain = []; // { blockHeight , block }
        }

        function getNum(val) {
            if (isNaN(val)) {
                return parseFloat(0);
            }
            return parseFloat(val);
        }

        // block chain methods 
        function getCurrentBlockHeight() {
            var maxValue = -1;
            for (var blockHeight in catShipChain) {
                if (blockHeight > maxValue) {
                    maxValue = blockHeight;
                }

            }
            return parseInt(maxValue);
        }

        function catShipCoinWallet() {
            var ec = new KJUR.crypto.ECDSA({
                'curve': 'secp256r1'
            });
            var keypair = ec.generateKeyPairHex();
            this.publicKey = keypair.ecpubhex; // hexadecimal string of EC public key
            this.privateKey = keypair.ecprvhex; // hexadecimal string of EC private key (=d)
        }

        // this is a prototype of a catship transaction, users will send stuff to each other by playing games and interacting
        function catShipTransaction(senderAddressIn, receiverAddressIn, messageIn, valueIn, prvhexIn) {
            this.senderAddress = senderAddressIn; // sender public key
            this.receiverAddress = receiverAddressIn; // receiver public key
            this.message = messageIn; // any message they want to write to the blockchain up to 128 chars
            this.value = valueIn; // amount being transfered

            // check the user has the funds
            //getUserBalance(senderAddressIn);

            /* when we create a transaction we sign the transaction before we get the message digest to ensure the transaction is immutable */
            var ec = new KJUR.crypto.ECDSA({
                'curve': 'secp256r1'
            });
            var transactionPlainText = this.senderAddress + this.receiverAddress + this.message + this.value;
            // sign the plain text of the entire transaction 
            this.signature = ec.signHex(transactionPlainText, prvhexIn);

            // now we hash the transaction including the signature to create the transaction ID
            var transactionPlainTextPlusSig = transactionPlainText + this.signature;
            var md = new KJUR.crypto.MessageDigest({
                alg: "sha384",
                "prov": "cryptojs"
            });
            md.updateString(transactionPlainTextPlusSig);
            this.transactionID = md.digest();

        }

        function validateTransaction(catShipTransactionIn) {
            // check balance of sender 

            // check the destination address is valid

            // check the signature validates against the public key (sender address)
        }

        // the prototype for the transaction block
        function catShipBlock(minerAddressIn) {

            // lets send the miner reward trans 
            var coinbaseTransaction = new catShipTransaction('catShipCoinBase', minerAddressIn, 'freshly minted kitty goodness', currentCoinReward, '');

            this.transactionArray = [];
            this.transactionArray.push(coinbaseTransaction);

            // the gameScoreArray contains the best scores each miner achieved for this block
            // here we really test the honesty of miners and can block miners who arent accepting scores
            this.gameScoreArray = []; // {publicKey - nonce} 
            var currentBlockHeight = getCurrentBlockHeight();
            if (currentBlockHeight == null) {
                this.blockHeight = parseInt(0);
            } else {
                this.blockHeight = parseInt(currentBlockHeight) + 1;
            }

            if (!(catShipChain[currentBlockHeight] == null)) {
                this.previousBlockID = catShipChain[currentBlockHeight].block.blockID;
            }

            // the block game hash is an sha384 hash of block height and previous block id so should be the same for all miners, this allows miners to be on an even footing when solving the puzzle
            // miners will use a nonce + blockGameHash to mine. 
            this.calculateBlockGameHash = function() {
                var blockPlainText = this.blockHeight + this.previousBlockID;
                var md = new KJUR.crypto.MessageDigest({
                    alg: "sha384",
                    "prov": "cryptojs"
                });
                md.updateString(blockPlainText);
                this.blockGameHash = md.digest();
            }
            // once the block has been solved the entire thing gets hashed and added to the blockchain to make it immutable
            this.calculateBlockID = function() {

                var transactionArrayString = JSON.stringify(this.transactionArray);
                var gameScoreArrayString = JSON.stringify(this.gameScoreArray);
                var blockPlainText = transactionArrayString + gameScoreArrayString + this.blockGameHash;
                // hash the solved block
                var md = new KJUR.crypto.MessageDigest({
                    alg: "sha384",
                    "prov": "cryptojs"
                });
                md.updateString(blockPlainText);
                this.blockID = md.digest();
            }

            this.closeBlock = function() {

                this.calculateBlockID();

                var tempBlock = {
                    "blockHeight": parseInt(this.blockHeight),
                    "block": this
                };
                catShipChain.push(tempBlock);

            }

        }

        function validateCatShipBlock(CatShipBlockIn) {
            var tempTransactionArray = CatShipBlockIn.transactionArray;
        }


        // create a genesis block for the cat ship chain 
        function initializeCatChain() {

            var firstBlock = new catShipBlock('04a0ca271b2e123e97001ccf99770d25e23f7b07f736d5f2399ad2ec446d10db1e766d61e3816d84994b99da593a0416c3555bf64a7b676d192b3e78106adfb20c');
            console.log(firstBlock);
            firstBlock.calculateBlockGameHash();
            firstBlock.closeBlock();
        }

        function getUserBalance(userAddressIn) {
            var userBalance = 0;

            // loop through all the blocks filtering out users address transactions
            for (var blockHeight in catShipChain) {
                console.log('checking height: ' + blockHeight + ' for address ' + userAddressIn);

                var credits = catShipChain[blockHeight].block.transactionArray.filter((trans) => trans.receiverAddress == userAddressIn);

                var debits = catShipChain[blockHeight].block.transactionArray.filter((trans) => trans.senderAddress == userAddressIn);

                var sum = parseFloat(0);
                for (var i = 0; i < credits.length; i++) {
                    sum += getNum(credits[i].value);
                };

                userBalance += getNum(sum);

                var sum = parseFloat(0);
                for (var i = 0; i < debits.length; i++) {
                    sum += getNum(debits[i].value);
                };

                userBalance -= getNum(sum);

            }
            console.log('users balance is: ' + userBalance);
            return userBalance;
        }

        console.log('********** initializing the catchain **********');

        if (typeof userWallet === 'undefined') {
            console.log('did not find a user Wallet, initializing a fresh one...');
            var userWallet = new catShipCoinWallet();
        }

        console.log('User wallet stringy:');
        var userWalletString = JSON.stringify(userWallet);
        console.log(userWalletString);

        if (catShipChain.length == 0) {
            console.log('did not find a cat ship block chain, initializing a fresh one...');
            initializeCatChain();
        }


        console.log('********** adding a new block and a few transactions **********');

        // create a new block
        var testBlock = new catShipBlock(userWallet.publicKey);

        // create a transaction 
        var testTransaction = new catShipTransaction(userWallet.publicKey, receiverPublicKey, userMessage, 12.00, userWallet.privateKey);

        // add transaction to the block
        testBlock.transactionArray.push(testTransaction);

        // create a transaction 
        var testTransaction = new catShipTransaction(userWallet.publicKey, receiverPublicKey, 'Have a kitkat!', 10.00, userWallet.privateKey);

        // add transaction to the block
        testBlock.transactionArray.push(testTransaction);

        console.log('********** mine the block **********');

        // this is the hash used by the puzzle
        testBlock.calculateBlockGameHash();

        // => mining code goes here

        // once mining is successfull close the block
        testBlock.closeBlock();

        var currentBal = getUserBalance(userWallet.publicKey);

        var catShipChainString = JSON.stringify(catShipChain);
        console.log(catShipChain);
        //console.log('stringy chain:' + catShipChainString);
    </script>

</body>

</html>